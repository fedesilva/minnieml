// Mini Ray Tracer in MML
// Renders a simple scene with spheres to a PPM image via stdout.
// Float operators (+. -. *. /. <. >.) and math functions (sqrt, fabs,
// int_to_float, float_to_int) are provided by the stdlib.

// --- Linear Algebra ---

struct Vec3 { x: Float, y: Float, z: Float };

inline fn vec_add(u: Vec3, v: Vec3): Vec3 =
  Vec3 (u.x +. v.x) (u.y +. v.y) (u.z +. v.z)
;

inline fn vec_sub(u: Vec3, v: Vec3): Vec3 =
  Vec3 (u.x -. v.x) (u.y -. v.y) (u.z -. v.z)
;

// Scalar multiplication: v * t
inline fn vec_scale(v: Vec3, t: Float): Vec3 =
  Vec3 (v.x *. t) (v.y *. t) (v.z *. t)
;

// Dot product
inline fn dot(u: Vec3, v: Vec3): Float =
  (u.x *. v.x) +. (u.y *. v.y) +. (u.z *. v.z)
;

inline fn length_squared(v: Vec3): Float = dot v v;

inline fn length(v: Vec3): Float = sqrt (length_squared v);

inline fn unit_vector(v: Vec3): Vec3 =
  vec_scale v (1.0 /. (length v))
;

// --- Scene Geometry ---

struct Ray { origin: Vec3, dir: Vec3 };

inline fn ray_at(r: Ray, t: Float): Vec3 =
  vec_add r.origin (vec_scale r.dir t)
;

struct Sphere { center: Vec3, radius: Float };

// Hit record (simplified: only t and normal needed for this demo)
struct Hit { t: Float, p: Vec3, normal: Vec3, did_hit: Bool };

inline fn no_hit(): Hit =
  let zero = Vec3 0.0 0.0 0.0;
  Hit 0.0 zero zero false
;

inline fn hit_sphere(s: Sphere, r: Ray, t_min: Float, t_max: Float): Hit =
  let oc = vec_sub r.origin s.center;
  let a = length_squared r.dir;
  let half_b = dot oc r.dir;
  let c = (length_squared oc) -. (s.radius *. s.radius);
  let discriminant = (half_b *. half_b) -. (a *. c);

  if discriminant <. 0.0 then
    no_hit ()
  else
    let sqrtd = sqrt discriminant;
    let root1 = ((0.0 -. half_b) -. sqrtd) /. a;
    
    // Check first root
    if (root1 <. t_max) and (root1 >. t_min) then
      let p = ray_at r root1;
      let normal = vec_scale (vec_sub p s.center) (1.0 /. s.radius);
      Hit root1 p normal true
    else
      // Check second root
      let root2 = ((0.0 -. half_b) +. sqrtd) /. a;
      if (root2 <. t_max) and (root2 >. t_min) then
        let p = ray_at r root2;
        let normal = vec_scale (vec_sub p s.center) (1.0 /. s.radius);
        Hit root2 p normal true
      else
        no_hit ()
      end
    end
  end
;

// --- World & Rendering ---

// Hardcoded world hit function (simulates a list of objects)
fn world_hit(r: Ray, t_min: Float, t_max: Float): Hit =
  let closest_so_far = t_max;
  let final_hit = no_hit ();

  // Sphere 1: Center (Small sphere)
  let s1 = Sphere (Vec3 0.0 0.0 (0.0 -. 1.0)) 0.5;
  let h1 = hit_sphere s1 r t_min closest_so_far;
  
  // Update closest hit if h1 hit
  let result1 = if h1.did_hit then
    h1 // New closest
  else
    final_hit // Keep previous (no hit)
  end;
  
  let t1 = if h1.did_hit then h1.t else closest_so_far end;

  // Sphere 2: Ground (Giant sphere)
  let s2 = Sphere (Vec3 0.0 (0.0 -. 100.5) (0.0 -. 1.0)) 100.0;
  let h2 = hit_sphere s2 r t_min t1;

  if h2.did_hit then h2 else result1 end
;

fn ray_color(r: Ray): Vec3 =
  let hit = world_hit r 0.001 1000000.0;
  
  if hit.did_hit then
    // Simple diffuse-like shading based on normal: 0.5 * (normal + 1)
    let n = hit.normal;
    let color_vec = Vec3 (n.x +. 1.0) (n.y +. 1.0) (n.z +. 1.0);
    vec_scale color_vec 0.5
  else
    // Background (Sky gradient)
    let unit_dir = unit_vector r.dir;
    let t = 0.5 *. (unit_dir.y +. 1.0);
    let white = Vec3 1.0 1.0 1.0;
    let blue = Vec3 0.5 0.7 1.0;
    // lerp: (1-t)*white + t*blue
    vec_add (vec_scale white (1.0 -. t)) (vec_scale blue t)
  end
;

// --- Batch Rendering ---
// Separate computation from I/O for SIMD vectorization opportunity.
// Each row is computed into FloatArrays, then written to the buffer.

fn compute_row(
  r_arr: FloatArray, 
  g_arr: FloatArray, 
  b_arr: FloatArray,
  i: Int, 
  j: Int, 
  width: Int, 
  height: Int,
  origin: Vec3, 
  ll_corner: Vec3, 
  horizontal: Vec3, 
  vertical: Vec3
): Unit =
  if i < width then
    let u = (int_to_float i) /. (int_to_float (width - 1));
    let v = (int_to_float ((height - 1) - j)) /. (int_to_float (height - 1));

    let hor_u = vec_scale horizontal u;
    let ver_v = vec_scale vertical v;
    let target = vec_add ll_corner (vec_add hor_u ver_v);
    let direction = vec_sub target origin;

    let r = Ray origin direction;
    let color = ray_color r;

    unsafe_ar_float_set r_arr i color.x;
    unsafe_ar_float_set g_arr i color.y;
    unsafe_ar_float_set b_arr i color.z;

    compute_row r_arr g_arr b_arr (i + 1) j width height
      origin ll_corner horizontal vertical
  end
;

fn write_row(
  buf: Buffer, 
  r_arr: FloatArray, 
  g_arr: FloatArray, 
  b_arr: FloatArray,
  i: Int, 
  width: Int
): Unit =
  if i < width then
    let ir = 255.999 *. (unsafe_ar_float_get r_arr i);
    let ig = 255.999 *. (unsafe_ar_float_get g_arr i);
    let ib = 255.999 *. (unsafe_ar_float_get b_arr i);

    buffer_write_int buf (float_to_int ir);
    buffer_write buf " ";
    buffer_write_int buf (float_to_int ig);
    buffer_write buf " ";
    buffer_writeln_int buf (float_to_int ib);

    write_row buf r_arr g_arr b_arr (i + 1) width
  end
;

fn render_rows(
  buf: Buffer, 
  r_arr: FloatArray, 
  g_arr: FloatArray, 
  b_arr: FloatArray,
  j: Int, 
  width: Int, 
  height: Int,
  origin: Vec3, 
  ll_corner: Vec3, 
  horizontal: Vec3, 
  vertical: Vec3
): Unit =
  if j >= 0 then
    compute_row r_arr g_arr b_arr 0 j width height
      origin ll_corner horizontal vertical;
    write_row buf r_arr g_arr b_arr 0 width;
    render_rows buf r_arr g_arr b_arr (j - 1) width height
      origin ll_corner horizontal vertical
  end
;

fn main(): Unit =
  // Image settings
  let aspect_ratio = 16.0 /. 9.0;
  let image_width = 400;
  let image_height = float_to_int ((int_to_float image_width) /. aspect_ratio);

  // Camera setup (computed once)
  let origin = Vec3 0.0 0.0 0.0;
  let viewport_height = 2.0;
  let viewport_width = viewport_height *. aspect_ratio;
  let focal_length = 1.0;
  let horizontal = Vec3 viewport_width 0.0 0.0;
  let vertical = Vec3 0.0 viewport_height 0.0;
  let ll_corner = Vec3
    (0.0 -. (viewport_width /. 2.0))
    (0.0 -. (viewport_height /. 2.0))
    (0.0 -. focal_length);

  // Per-row float buffers (allocated once, reused across rows)
  let r_arr = ar_float_new image_width;
  let g_arr = ar_float_new image_width;
  let b_arr = ar_float_new image_width;

  // Stdout buffer
  let buf = mkBufferWithFd 1;

  // PPM Header
  buffer_writeln buf "P3";
  buffer_write_int buf image_width;
  buffer_write buf " ";
  buffer_writeln_int buf image_height;
  buffer_writeln buf "255";

  // Render
  render_rows buf r_arr g_arr b_arr (image_height - 1) image_width image_height
    origin ll_corner horizontal vertical;

  flush buf
;
