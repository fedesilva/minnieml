// astar.mml
// This benchmark simulates routing a path across a 100x100 discrete 2D grid,
// navigating from the top-left corner to the bottom-right destination while avoiding a vertical wall obstruction.
// It models a standard grid-based navigation environment—similar to a video game map or a simplified circuit
// layout—where an agent must calculate the optimal Manhattan-distance route through open cells,
// constrained to moving in the four cardinal directions (up, down, left, right) without colliding with the
// defined barrier.

// ---------------------------------------------------------
// 1. Min-Heap Implementation
// ---------------------------------------------------------

struct MinHeap {
  indices: IntArray,
  scores:  IntArray,
  capacity: Int
};


fn heap_new (cap: Int): MinHeap =
  MinHeap
    (ar_int_new cap)
    (ar_int_new cap)
    cap
;

struct PopResult {
  size: Int,
  idx: Int
};


fn heap_swap (h: MinHeap, i: Int, j: Int): Unit =
  let idx_i = unsafe_ar_int_get (h.indices) i;
  let scr_i = unsafe_ar_int_get (h.scores) i;
  let idx_j = unsafe_ar_int_get (h.indices) j;
  let scr_j = unsafe_ar_int_get (h.scores) j;

  unsafe_ar_int_set (h.indices) i idx_j;
  unsafe_ar_int_set (h.scores) i scr_j;
  unsafe_ar_int_set (h.indices) j idx_i;
  unsafe_ar_int_set (h.scores) j scr_i
;

fn sift_up (h: MinHeap, idx: Int): Unit =
  if idx > 0 then
    let parent = (idx - 1) / 2;
    let p_score = unsafe_ar_int_get (h.scores) parent;
    let c_score = unsafe_ar_int_get (h.scores) idx;

    if c_score < p_score then
      heap_swap h idx parent;
      sift_up h parent
    else () end
  else () end
;

fn sift_down (h: MinHeap, size: Int, idx: Int): Unit =
  let left = 2 * idx + 1;
  let right = 2 * idx + 2;

  let s_score = unsafe_ar_int_get (h.scores) idx;

  // Find smallest among idx, left, right
  let smallest =
    if left < size then
      if (unsafe_ar_int_get (h.scores) left) < s_score
      then left else idx end
    else idx end;

  let smallest =
    if right < size then
      if (unsafe_ar_int_get (h.scores) right) < (unsafe_ar_int_get (h.scores) smallest)
      then right else smallest end
    else smallest end;

  if smallest != idx then
    heap_swap h idx smallest;
    sift_down h size smallest
  else () end
;

fn heap_push (h: MinHeap, size: Int, grid_idx: Int, f_score: Int): Int =
  unsafe_ar_int_set (h.indices) size grid_idx;
  unsafe_ar_int_set (h.scores) size f_score;
  sift_up h size;
  size + 1
;

fn heap_pop (h: MinHeap, size: Int): PopResult =
  if size == 0 then PopResult 0 (0 - 1)
  else
    let root = unsafe_ar_int_get (h.indices) 0;
    let last = size - 1;

    let last_idx = unsafe_ar_int_get (h.indices) last;
    let last_scr = unsafe_ar_int_get (h.scores) last;

    unsafe_ar_int_set (h.indices) 0 last_idx;
    unsafe_ar_int_set (h.scores) 0 last_scr;

    sift_down h last 0;
    PopResult last root
  end
;

// ---------------------------------------------------------
// 2. A* Logic
// ---------------------------------------------------------

fn abs (x: Int): Int = if x < 0 then 0 - x else x end;

fn heuristic (idx_a: Int, idx_b: Int, width: Int): Int =
  let x1 = idx_a % width;
  let y1 = idx_a / width;
  let x2 = idx_b % width;
  let y2 = idx_b / width;
  (abs (x1 - x2)) + (abs (y1 - y2))
;

fn init_g (g_score: IntArray, inf: Int, total: Int, i: Int): Unit =
  if i < total then
    unsafe_ar_int_set g_score i inf;
    init_g g_score inf total (i + 1)
  end
;

fn visit_neighbors (
  open_set: MinHeap, g_score: IntArray, walls: IntArray,
  goal_idx: Int, width: Int, height: Int,
  current: Int, cx: Int, cy: Int,
  dir: Int, heap_sz: Int
): Int =
  if dir == 4 then
    solve open_set g_score walls goal_idx width height heap_sz
  else
    let neighbor_idx =
      if dir == 0 then current + 1
      elif dir == 1 then current - 1
      elif dir == 2 then current + width
      else current - width end;

    let valid =
      if dir == 0 then cx < (width - 1)
      elif dir == 1 then cx > 0
      elif dir == 2 then cy < (height - 1)
      else cy > 0 end;

    if valid then
      if (unsafe_ar_int_get walls neighbor_idx) == 1 then
        visit_neighbors open_set g_score walls goal_idx width height
          current cx cy (dir + 1) heap_sz
      else
        let tentative_g = (unsafe_ar_int_get g_score current) + 1;

        if tentative_g < (unsafe_ar_int_get g_score neighbor_idx) then
          unsafe_ar_int_set g_score neighbor_idx tentative_g;
          let f = tentative_g + (heuristic neighbor_idx goal_idx width);
          let new_sz = heap_push open_set heap_sz neighbor_idx f;
          visit_neighbors open_set g_score walls goal_idx width height
            current cx cy (dir + 1) new_sz
        else
          visit_neighbors open_set g_score walls goal_idx width height
            current cx cy (dir + 1) heap_sz
        end
      end
    else
      visit_neighbors open_set g_score walls goal_idx width height
        current cx cy (dir + 1) heap_sz
    end
  end
;

fn solve (
  open_set: MinHeap, g_score: IntArray, walls: IntArray,
  goal_idx: Int, width: Int, height: Int,
  h_size: Int
): Int =
  if h_size == 0 then (0 - 1)
  else
    let pop_res = heap_pop open_set h_size;
    let current = pop_res.idx;
    let current_h_size = pop_res.size;

    if current == goal_idx then
      unsafe_ar_int_get g_score goal_idx
    else
      let cx = current % width;
      let cy = current / width;
      visit_neighbors open_set g_score walls goal_idx width height
        current cx cy 0 current_h_size
    end
  end
;

fn astar (width: Int, height: Int, start_idx: Int, goal_idx: Int, walls: IntArray): Int =
  let size = width * height;
  let inf = 999999999;
  let g_score = ar_int_new size;

  init_g g_score inf size 0;
  unsafe_ar_int_set g_score start_idx 0;

  let open_set = heap_new size;
  let initial_h = heuristic start_idx goal_idx width;
  let init_heap_size = heap_push open_set 0 start_idx initial_h;

  solve open_set g_score walls goal_idx width height init_heap_size
;

fn build_wall (walls: IntArray, w: Int, i: Int): Unit =
  if i < 50 then
    let idx = 50 * w + (25 + i);
    unsafe_ar_int_set walls idx 1;
    build_wall walls w (i + 1)
  end
;

fn main (): Unit =
  let w = 100;
  let h = 100;
  let size = w * h;
  let walls = ar_int_new size;

  build_wall walls w 0;

  let start = 0;
  let goal = size - 1;

  let cost = astar w h start goal walls;

  println (int_to_str cost)
;
