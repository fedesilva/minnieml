// Helper to swap two elements
fn swap(arr: IntArray, a: Int, b: Int): Unit =
  let tmp = unsafe_ar_int_get arr a;
  unsafe_ar_int_set arr a (unsafe_ar_int_get arr b);
  unsafe_ar_int_set arr b tmp
;

// The inner loop of partition: for (j = low; j < high; j++)
// Returns the final value of 'i' (the pivot index)
fn partition_loop(arr: IntArray, j: Int, high: Int, pivot: Int, i: Int): Int =
  if j < high then
    let val = unsafe_ar_int_get arr j;
    if val < pivot then
      let new_i = i + 1;
      swap arr new_i j;
      partition_loop arr (j + 1) high pivot new_i
    else
      partition_loop arr (j + 1) high pivot i
    end
  else
    i
  end
;

fn partition(arr: IntArray, low: Int, high: Int): Int =
  let pivot = unsafe_ar_int_get arr high;
  let i_start = low - 1;
  // Run the loop to place elements smaller than pivot
  let final_i = partition_loop arr low high pivot i_start;
  // Place pivot in the correct spot
  swap arr (final_i + 1) high;
  final_i + 1
;

fn quicksort(arr: IntArray, low: Int, high: Int): Unit =
  if low < high then
    let p = partition arr low high;
    quicksort arr low (p - 1);
    quicksort arr (p + 1) high
  end
;

// Standard Linear Congruential Generator for deterministic random numbers
fn fill_random(arr: IntArray, seed: Int, i: Int, size: Int): Unit =
  if i < size then
    // LCG: next = (prev * 1664525 + 1013904223) % 2^32
    // We simulate 32-bit wrap with bitwise AND if needed, or just let it ride on 64-bit
    let next = (seed * 1664525) + 1013904223;
    // Keep it positive and manageable for sort checking
    let val = next % 100000;
    unsafe_ar_int_set arr i val;
    fill_random arr next (i + 1) size
  end
;

fn run_sort(size: Int): Int =
  let arr = ar_int_new size;
  fill_random arr 42 0 size;
  quicksort arr 0 (size - 1);
  // Return middle element to verify
  unsafe_ar_int_get arr (size / 2)
;

fn main(): Unit =
  // Sort 1 million integers
  let result = run_sort 1000000;
  println (concat "Median checksum: " (to_string result))
;