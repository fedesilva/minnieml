// The following types are a sample of the standard library plus some use examples
// Maybe could be a type def like: `type Maybe 'T = 'T | ()`
// But enums are more flexible - with an enum when you need say One x,
// which inference precise as can be for x.
// You know it has type Maybe 'T for whatever 'T.
// With a union type it will be frequently inferred as either unit or the concrete type
// See usage below

enum Maybe 'T =
  | One: 'T
  | None
;

// Puts Maybe members in the current scope to allow using them unqualified
// (One instead of Maybe.One)
use Maybe.*;

// empty :: Maybe 'T -> Boolean
fn empty(x) =
  match x with
    | None -> true
    | _    -> false
  end
;

// nonEmpty :: Maybe 'T -> Boolean
fn nonEmpty(maybe) =
  not empty maybe
;

enum Result 'T 'E =
  | Ok: 'T
  | Err: 'E
;

// Semigroup represents an associative binary operation.
protocol Semigroup 'T =
  fn combine: 'T -> 'T -> 'T;
;

// Monoid requires 'T to also satisfy Semigroup.
protocol Monoid 'T: Semigroup =
  fn empty: 'T;
;

// Functor represents a structure that can be mapped over.
protocol Functor 'F =
  fn map 'A 'B : ('A -> 'B) -> ('F 'A) -> ('F 'B);
;

// Apply requires 'F to also satisfy Functor.
protocol Apply 'F: Functor =
  fn ap 'A 'B : ('F ('A -> 'B)) -> ('F 'A) -> ('F 'B);
;

// Applicative requires 'F to also satisfy Apply.
protocol Applicative 'F: Apply =
  fn pure 'A : 'A -> 'F 'A;
;

// FlatMap requires 'F to also satisfy Functor.
protocol FlatMap 'F: Functor =
  fn flatMap 'A 'B : ('A -> 'F 'B) -> 'F 'A -> 'F 'B;
;

// Monad requires 'M to also satisfy Functor, FlatMap, and Applicative.
protocol Monad 'M: Functor & FlatMap & Applicative;

protocol Foldable 'F =
  fn foldLeft 'A 'B : ('B -> 'A -> 'B) -> 'B -> 'F 'A -> 'B;
  fn foldRight 'A 'B : ('A -> 'B -> 'B) -> 'B -> 'F 'A -> 'B;
;

// Int forms a semigroup under addition
instance Semigroup Int =
  fn combine(x, y) = x + y
;

// Int forms a monoid under addition with 0 as identity
instance Monoid Int =
  fn empty() = 0
;

// Maybe implements the Functor protocol
instance Functor Maybe =
  fn map(f, maybe) =
    match maybe with
      | One x -> One(f x)
      | None  -> None
    end
;

// Maybe implements the Apply protocol
instance Apply Maybe =
  fn ap(f, maybe) =
    match f with
      | One g -> map g maybe
      | None  -> None
    end
;

// Maybe implements the FlatMap protocol
instance FlatMap Maybe =
  fn flatMap(f, maybe) =
    match maybe with
      | One x -> f x
      | None  -> None
    end
;

// Maybe implements the Applicative protocol
instance Applicative Maybe =
  fn pure(x) = One x
;

// Maybe implements the Monad protocol
instance Monad Maybe =
  fn flatMap(f, maybe) =
    match maybe with
      | One x -> f x
      | None  -> None
    end
  fn pure(x) = One x
;

protocol Something 'T: Semigroup 'T =
  fn combine(x, y) = x + y;
  // Example of operator definitions using protocols
  // Here the precedence and associativity are randomly 
  // selected for demonstration only.
  op + 20 right : ('T, 'T) -> 'T;
  op >> 25 left :  ('T, 'T) -> 'T;
;
