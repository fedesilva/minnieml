This are notes about MinnieML (mml), a functional programming language.

this is a language in development by myself.

This is reference for future conversation

---------------------------------------------------------------------------------------------------------------------------------------------------

for reference for further conversation, assume in mml there are types like

* String which is a string representation, and all string literals should have this type
* numeric protocols in the spirit of scala's spire that support the following number types
* Int and Long which is corresponds to 32 and 64 bit integers
* Float and Double which correspond to 32 and 64 bit floating point numbers
* BigDecimal and BigInteger implemented  using record types
* Maybe which encodes optional types defined under the "Predefined tyoes" sections below.
* Result which encodes the possibility of having a successful or a failed result of a computation
* LocalDate, LocalDateTime, ZoneDate and ZonedDateTime, Instant  port of java's new date types and all associated operations

Assume a hindley milner type checker with extensions for the types defined in the grammar,
particularly under the tpSpec rules, protocols (protocols are types) and enums.
Assume that enum members, module members and members instances of protocols too can can be imported into scope using `use Module.X` or everything with `Module._`
so that they can be referenced directly (None, instead of Maybe.None)

Assume unboxed primitives and an arena memory manager with allocation instructions generated by the language using type info,
flow info (usage) and escape analysis using llvm for codegen.

note that indentation is not significant in mml,
instances, protocols, modules nested modules and export tables have to be closed with a ; and we like to place the ; in its own line.

it is crucial that you always provide samples of code using the grammar and the following examples as reference.
it is ok to reason in other more common languages (like scala, haskell or ocaml) but translate and double check the
grammar and the examples.


---------------------------------------------------------------------------------------------------------------------------------------------------

for reference for further conversation here are some definitions with commentary  and some examples of usage


use
  Functor.map,
  Maybe._,
  Semigroup.combine

let xs = LinkedList [ 1 2 3 ]

# double: Int -> Int
fn double x = x * 2

# [ 2 4 6 ]
let doubled = map double xs

# partial application!
# doubler: LinkedList 'T -> LinkedList 'T
let doubler = map double

# [ 4 8 12 ]
let twice = doubler doubled

# lambda (function literal)
# (x -> x + 1)
# lambdas with multiple parameters look like this
# a -> b -> a + b
# which reflects the fact that functions are curried by default
# and can be partially applied
# but the shorthand syntax is more idiomatic
# because it cuts on the arrows as parameter lists grow in size
# a b -> a+b
# x y z -> Point3D x y z

# [ 2 3 4 ]
let incremented = map (x -> x + 1) xs

# [ 1 2 3 2 3 4 ]
let combined = combine xs incremented

let maybeString = One "fede"


# Define a function wrapped in Maybe.
let maybeFn = One (x -> x + 1)

# Define a value wrapped in Maybe.
let maybeVal = One 3

# brings into scope the members
use Apply._

# Apply the function to the value using Apply's ap.
let result = ap maybeFn maybeVal

# Define two functions that can fail.
let tryDivideByTwo = x -> if x % 2 == 0 then One (x / 2) else None
let tryAddOne =  x -> if x >= 0 then One (x + 1) else None

# Define a value to operate on.
let value = 4

# Use flatMap to sequence the operations.
let result = FlatMap.flatMap tryDivideByTwo (FlatMap.flatMap tryAddOne value)



# Random examples

let name =
  person match
    | Person { name } -> name
    | p @ Person      -> nameOf p
    | _               -> "unknown"



(** lalala *)
fn matcher ('T: Num) : String match
  | A                 -> "a"
  | f @ 'T -> String  -> f z
  | s ->
      let str = show s,
          otr = "other"
      in
        upperCase (concat str otr)


let a: String =
  x match
    | 1                 -> "1"
    | 2                 -> "2"
    | (a, _)            -> a
    | Person { name }   -> name     # nominal
    | {name}            -> name     # structural
    | a: String         -> a
    | Monday            -> "monday"
    | Numbr a           -> num2String a
    | One _             -> "one"


# type arguments and normal arguments can be grouped (separately)
fn sum ('A: Num 'B: Num) (a: 'A b: 'B): Num =
  a + b

# grouping avoids ambiguities,
# here we are saying that the function returns an String,
# otherwise, this
# fn matcher 'T : String match ...
# would mean that the type argument 'T has a String constraint.
fn matcher ('T) : String match
  | A                 -> "a"
  | f @ 'T -> String  -> f z
