This is  the antlr 4 grammar  for a language called MinnieML (mml for short).
Don't summarize unless I ask, I will provide a series of prompts with more context and sample code
before asking more questions

this is a language in development

---------------------------------------------------------------------------------------------------------------------------------------------------

for reference for further conversation, assume in mml there are types like

* String which is a string representation, and all string literals should have this type
* numeric protocols in the spirit of scala's spire that support the following number types
* Int and Long which is corresponponds to 32 and 64 bit integers
* Float and Double which correspond to 32 and 64 bit floating point numbers
* BigDecimal and BigInteger implemented  using record types
* Maybe which encodes optional types defined under the "Predefined tyoes" sections below.
* Result which encodes the possibility of having a successful or a failed result of a computation
* LocalDate, LocalDateTime, ZoneDate and ZonedDateTime, Instant  port of java's new date types and all associated operations

Assume a hindley milner type checker with extensions for the types defined in the grammar,
perticularly under the tpSpec rules, protocols (protocols are types) and enums.
Assume that enum members, module members and members instances of protocols too can can be imported into scope using `use Module.X` or everything with `Module._`
so that they can be referenced directly (None, instead of Maybe.None)

Assume unboxed primitives and an arena memory manager with allocation instructions generated by the language using type info, flow info (usage) and escape analysis
using llvm for codegen.

note that indentation is not significant in mml,
instances, protocols, modules nested modules and export tables have to be closed with a ; and we like to place the ; in its own line.

always provide samples of code using the grammar and the following examples as reference.

When I am finished with the series of prompts with examples I will say "Done init".

---------------------------------------------------------------------------------------------------------------------------------------------------

for reference for further conversation here are some definitions with commentary  and some examples of usage


use Functor.map,
         Maybe._,
         Semigroup.combine

let xs = LinkedList [ 1 2 3 ]

# double: Int -> Int
fn double x = x * 2

# [ 2 4 6 ]
let doubled = map double xs

# partial application!
# doubler: LinkedList 'T -> LinkedList 'T
let doubler = map double

# [ 4 8 12 ]
let twice = doubler doubled

# lambda (function literal)
# (x -> x + 1)
# lambdas with multiple parameters look like this
# a -> b -> a + b
# which reflects the fact that functions are curried by default
# and can be partially applied
# but the shorthand syntax is more idiomatic
# because it cuts on the arrows as parameter lists grow in size
# a b -> a+b
# x y z -> Point3D x y z

# [ 2 3 4 ]
let incremented = map (x -> x + 1) xs

# [ 1 2 3 2 3 4 ]
let combined = combine xs incremented

let maybeString = One "fede"


# Define a function wrapped in Maybe.
let maybeFn = One (x -> x + 1)

# Define a value wrapped in Maybe.
let maybeVal = One 3

# brings into scope the members
use Apply._

# Apply the function to the value using Apply's ap.
let result = ap maybeFn maybeVal

# Define two functions that can fail.
let tryDivideByTwo = x -> if x % 2 == 0 then One (x / 2) else None
let tryAddOne =  x -> if x >= 0 then One (x + 1) else None

# Define a value to operate on.
let value = 4

# Use flatMap to sequence the operations.
let result = FlatMap.flatMap tryDivideByTwo (FlatMap.flatMap tryAddOne value)



