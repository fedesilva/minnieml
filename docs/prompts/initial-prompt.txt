Given the antlr 4 grammar ( presented below between BEGIN_GRAMMAR and END_GRAMMAR) for a language called MinnieML (mml for short)
assume there are types 

* String which is a string representation, and all string literals should have this type
* Int which is corresponponds to a 64 bit integer (use llvm i64 as a reference)
* Float which corresponds to a 64 bit floating point (use a corresponding llvm type)
* Maybe which encodes optional types defined under the "Predefined tyoes" sections below.
* Result which encodes the possibility of having a successful or a failed result of a computation
* LocalDate similar to java's new date types
* Interval similar to java's new data tupes

Assume a hindley milner type checker.


Predefined types:

union Maybe 'T =
  | One: 'T
  | None

union Result 'T 'E =
  | Ok: 'T
  | Err: 'E

Examples of code:

# A Semigroup is a type with an associative binary operation.
data Semigroup 'T {
  assoc: ('T 'T) -> 'T
}

# A Monoid is a Semigroup with an identity element.
data Monoid 'T {
  semigroup: Semigroup 'T
  id: 'T
}

# A Group is a Monoid with an inverse operation.
data Group 'T {
  monoid: Monoid 'T
  inverse: 'T -> 'T
}

# An AbelianGroup is a Group with a commutative binary operation.
data AbelianGroup 'T {
  group: Group 'T
}

# A Ring is a type with two binary operations (addition and multiplication) that satisfy some laws.
data Ring 'T  {
  additiveMonoid: Monoid 'T
  multiplicationSemigroup: Semigroup 'T
  zero: 'T
  one: 'T
  negation: 'T -> 'T
}

# A Field is a Ring with multiplicative inverses.
data Field 'T {
  ring: Ring 'T
  inverse: 'T -> 'T
}


data Person {
    name : String
    age : Int
    pet : OptionalPet
}

enum Species = | Cat | Doc | Parrot

data Pet {
    petName : String
    species : Species
}

union OptionalPet =
    | NoPet
    | SomePet : Pet

let p = Person "Fede" 50 OptionalPet.NoPet

let c = Pet "Zur" Species.Cat

fn nameOf(x): String = x.name

let nameOfPerson = nameOf p
let nameOfCat = nameOf c


BEGIN_GRAMMAR

grammar MinnieML;

// Parser Rules ----------------------------------------------------------------------

// Script Rules ----------------------------------------------------------------------

//
// `Script` represents a scripting session's syntax.
//  Not used by normal compiler, scripts are a bit more lenient.
// Syntactically you can write an expression that does not bind it's result, a statement.
// The effects system is far more lenient, too.
//
script: ( stat | member )* EOF;

// A statement ignores results if any and evaluates effects immediately
// Scripts dont enforce effectful segregation
stat: exp(End)?;

// ----------------------------------------------------------------------
// Full language rules follow
// ----------------------------------------------------------------------

// Modules --------------------------------------------------------------

modVisibility: pub | protd | lexical;

// Public modules are accessible from everywhere
// Default for top level modules unless specified otherwise
pub: Pub;

// Protected modules are only accesible from siblings and parent
// default if not specified otherwise
protd: Protd;

// Lexically visible modules are accesible by children of the declaring module.
lexical: Lexical;

module:
  (doc)? (modVisibility)? (Module moduleId Def)? (moduleExports)? (member)+ EOF ;

nestedModule:
  (doc)? (modVisibility)? Module moduleId Def (moduleExports)? (member)+(End)?;

exportSelection:
  (id | tpId | moduleId | selection);

exportReSpec:
  (idMWT | tpId | moduleId);

exportedMember:
  (doc)? ( exportReSpec '=' )? (exportSelection);

moduleExports:
  (doc)? Exports Def ( exportedMember )+(End)?;

member: ( decl | comm );

decl:
  letBnd        |
  fn            |
  fnM           |
  op            |
  nestedModule  |
  dt            |
  variant       |
  tpAlias       |
  protocol      |
  instance      ;

// ----------------------------------------------------------------------
// Expressions
//
// Application, Operators, precedence, associativity, type construction, etc,
// are all recognized post parsing
//

group: Lpar ( exp )+ Rpar;

exp:
  flatExp                       #flatExpL       |
  fnMatchLit                    #fnMatchLitL    |
  left = exp Match matchBody    #matchExpL      ;

flatExp:
    (
      group     |
      fnLit     |
      lit       |
      id        |
      tpId      |
      opId      |
      moduleId  |
      tuple     |
      selection |
      cond      |
      dtCons    |
      hole
    )+
;

selection: ( id | moduleId ) Dot (id | moduleId) (Dot (id | moduleId) )*;

hole: Hole;

//
// Protocols ----------------------------------------------------
//

protocol: Protocol tpId typeArgs LCurly protocolBody RCurly;
protocolBody: ( id '=' fnSig )+;

instance:  Instance tpId tpSpec LCurly instanceBody RCurly;
instanceBody: ( id '=' fnSig Def fnExp )+;



//
// Pattern matching ----------------------------------------------------
//

matchBody: matchCase ( matchCase )*;
matchCase: '|' matchBnd? patt ( If exp )? Def fnExp ;
matchBnd: (id '@');


patt: lit           |
      idOrMeh       |
      tpSpec        |
      tupleDecon    |
      nominalDecon  |
      tpId id       |
      structDecon   ;

// ----------------------------------------------------------------------
// Function and/or binding modifiers

rec:  Rec;
lazy: Lazy;
cnst: Const;

// ----------------------------------------------------------------------
// Bindings

bnd:  idMWT         Def exp  |
      tupleDecon    Def exp  |
      nominalDecon  Def exp  |
      structDecon   Def exp  ;

letBnd: (doc)? Let (lazy|cnst)? (rec)? (doc)? bnd (',' (doc)? bnd)* (End)? ;

// ----------------------------------------------------------------------
// Functions

fnLet:  (doc)? Let bnd (',' bnd)* In fnExp (Where fnLetWhereFn (',' fnLetWhereFn)*  )? ;
fnLetWhereFn: (rec)? id fnSig Def fnExp;

fnExp: exp | fnLet;

fnSig: (typeArgs)? formalArgs (returnTp)?;

formalArgs: idMWT* | '(' idMWT* ')';

returnTp: TpAsc tpSpec;

fn:    (doc)? Fn (rec)? id fnSig Def fnExp (End)?;
fnM:   (doc)? Fn (rec)? id ( (typeArgs)? | Lpar (typeArgs)? Rpar )  (returnTp)? Match matchBody End ;

fnLit:      fnSig TArrow fnExp;
fnMatchLit: Meh Match matchBody;

// Operators ----------------------------------------------------------------------

op: binOp | prefixOp | postfixOp;

binOp:       (doc)? Op opId (opPrecedence)? (typeArgs)? idMWT idMWT (returnTp)? Def fnExp(End)?;
prefixOp:    (doc)? Op opId Dot (opPrecedence)? (typeArgs)? idMWT (returnTp)?   Def fnExp(End)?;
postfixOp:   (doc)? Op Dot opId (opPrecedence)? (typeArgs)? idMWT (returnTp)?   Def fnExp(End)?;

opPrecedence:  LitPrec;

// Conditional expression ----------------------------------------------------------------------

cond: If cndThenExp (Else If cndThenExp)? cndElse;

cndThenExp: exp Then fnExp;
cndElse: Else fnExp;

// TYPES ---------------------------------------------------------------------------------------

// Type alias
tpAlias: Type tpId (typeArgs)? Def tpSpec(End)?;

// General type declaration related rules

typeArgs: tpArgId typeArgs | tpArgId;

tpArgId: TpArgId | tpArgId TpAsc tpSpec;

tpSpec:
    Lpar (tpSpec)+ Rpar                           #groupSpec            |
    tpId                                          #nameSpec             |
    tpArgId                                       #argSpec              |
    left = tpSpec ( '&' tpSpec )+                 #intersectSpec        |
    left = tpSpec ( '|' tpSpec )+                 #unionSpec            |
    left = tpSpec (TArrow left = tpSpec)+         #fnSpec               |
    LCurly dtField (dtField)* RCurly              #structSpec           |
    tpSpec (',' tpSpec)+                          #tupleSpec            |
    left = tpSpec ( tpSpec )+                     #tpAppSpec            ;


// -----------------------------------------------------------------------------
// Product types ---------------------------------------------------------------
// -----------------------------------------------------------------------------

// Data types ----------------------------------------------------------------------

dtField: (doc)? idMWT;

dt: (doc)? Data tpId (typeArgs)? LCurly dtField (dtField)* RCurly (End)?;

dtNamedAssign: Id Def exp;

dtCons: tpId ( dtNamedAssign | exp )+;

nominalDecon: tpId LCurly (idMWT)+ RCurly;

structDecon: LCurly idMWT RCurly;

// Tuples ----------------------------------------------------------------------

tuple: Lpar exp (',' exp)+  Rpar;

tupleDecon: Lpar idOrMeh ',' idOrMeh ( ',' idOrMeh )*  Rpar;

// -----------------------------------------------------------------------------
// Sum types -------------------------------------------------------------------
// -----------------------------------------------------------------------------


// Variants  -------------------------------------------------------------------

variant: enumV | unionV;

// Union  -------------------------------------------------------------------

unionV: (doc)? Union tpId (typeArgs)? Def unionMbr ( unionMbr )+ (End)?;

unionMbr:  (doc)?  '|'  tpId ( TpAsc tpSpec)?;


// Enum -------------------------------------------------------------------

enumV:  (doc)? Enum tpId Def enumMbr ( enumMbr)+ (End)?;

enumMbr:  (doc)? '|' tpId;


//
// Literals ----------------------------------------------------------------------
//

lit: litStr | litInt | litLong | litFloat | litDouble | litUnit | litBoolean;

litStr: LitStr;
litInt:  LitInt;
litLong: LitLong;

litFloat:  LitFloat;
litDouble: LitDouble;

litBoolean: (litTrue | litFalse);
litTrue: LitTrue;
litFalse: LitFalse;

litUnit: LitUnit;

// Comments  ----------------------------------------------------------------------

doc: Doc;

comm: (hComm | mlComm) ;

hComm: HComm;

mlComm: MLComm;

// Ids ----------------------------------------------------------------------

id:       Id;
idMWT:    id (TpAsc tpSpec)?;
idOrMeh:  Meh | idMWT;
moduleId: FirstUpId;
tpId:     FirstUpId;
opId:     SymId | Id;

// Lexer Rules ----------------------------------------------------------------------

// Literals
LitStr:   '"' .*? '"';
LitInt:   [0-9]+;
LitFloat: [0-9]*'.'[0-9]+;
LitLong:  [0-9]+'L';
LitDouble: [0-9]*'.'[0-9]+'D';
LitTrue:  'true';
LitFalse: 'false';
LitUnit : '()';
LitPrec: '[' [1-10] ']';

// Keywords
Type :      'type';
TpAsc:      ':';
Let :       'let';
Where:      'where';
Rec:        'rec';
Const:      'const';
Fn :        'fn';
In:         'in';
If:         'if';
Then:       'then';
Else:       'else';
Module:     'module';
Pub:        'pub';
Protd:      'protected';
Lexical:    'lexical';
Exports:    'exports';
Use:        'use';
Enum:       'enum';
Union:      'union';
Data:       'data';
Match:      'match';
Lazy:       'lazy';
Or:         'or';
And:        'and';
TArrow:     '->';
Op:         'op';
End :       ';';
Def :       '=';
Dot:        '.';
Lpar :      '(';
Rpar :      ')';
LCurly:     '{';
RCurly:     '}';
LBrac:      '[';
RBrac:      ']';
Derives:    '<:';
Hole:       '???';
Meh:        '_';
Compose:    '<|';
AndThen:    '|>';
Protocol:   'protocol';
Instance:   'instance';

// Identifiers

// a value binding id starts with a lowercase letter
Id : FirstLowId;

// A type parameter starts with a ' and an upper case letter
TpArgId : [']FirstUpId;

FirstLowId: [a-z][A-Za-z0-9_]*;
FirstUpId : [A-Z][A-Za-z0-9]* ;

SymId : ( '/' | '*' | '+' | '-' | '>' | '<' | '=' | ':' | '|' | '%' | '\\' | '^' | '!' | '~' | '?'  )+;

// Whitespace
Newline : ('\r\n' | '\n')   -> channel(1);
WS      : [\t ]+            -> channel(1);

// Comments
// Doc comment
Doc     : '(**' (Doc|MLComm|.)*? '*)';
// Multiline comment
MLComm  : '(*' (MLComm|Doc|.)*? '*)'        -> channel(2);
// Line comment
HComm   : '#' .*? ('\r\n' | '\n' | EOF)     -> channel(2);

END_GRAMMAR

Wait for questions, and when you provide MinnieML (mml for short) code, use the same indentation style as the examples provided, and  strictly follow the provided grammar
