Given the antlr 4 grammar ( presented below between BEGIN_GRAMMAR and END_GRAMMAR) for a language called MinnieML (mml for short)
assume there are types like

* String which is a string representation, and all string literals should have this type
* numeric protocols in the spirit of scala's spire that support the following number types
* Int and Long which is corresponponds to 32 and 64 bit integers
* Float and Double which correspond to 32 and 64 bit floating point numbers
* BigDecimal and BigInteger implemented  using record types
* A protocol and adt library in the spirit of Scala Cats, monads, monoids, functors, etc.
  * for now minus the async core.
* Maybe which encodes optional types defined under the "Predefined tyoes" sections below.
  - see below
* Result which encodes the possibility of having a successful or a failed result of a computation
  - see below
* LocalDate, LocalDateTime, ZoneDate and ZonedDateTime, Instant  port of java's new date types and all associated operations

Assume a hindley milner type checker with extensions for the types defined in the grammar,
perticularly under the tpSpec rules, protocols (protocols are types) and enums.

Assume that enum members can be imported into scope (undefine syntax as of yet but assume they can be)
so that they can be referenced directly (None, instead of Maybe.none)

Predefined types:

enum Maybe 'T =
  | One: 'T
  | None

enum Result 'T 'E =
  | Ok: 'T
  | Err: 'E

enum LinkedList 'T =
  | Nil
  | Cons: 'T , (LinkedList 'T)


# give me a function from A to B and an A inside an F and
#    I'll give you a B inside an F
protocol Functor 'F =
  map  'A 'B : ('A -> 'B) -> ('F 'A) -> ('F 'B)
;

# semigroups are things that can be combined ussing an associative operation
protocol Semigroup 'T =
  combine: 'T -> 'T -> 'T
;

# Monoid is a semigroup with an identity (zero) element.
protocol Monoid 'T <: Semigroup 'T =
  empty:  'T
;

enum LinkedList 'T =
  | Empty
  | Cons: 'T , (LinkedList 'T)

instance Functor (LinkedList 'T) =
  fn map f xs =
      xs match
        | Nil -> Nil
        | [ head :: tail ] -> Cons (f head) (map f tail)
;

instance Semigroup LinkedList 'T =
  fn combine xs ys =
   xs match
    | Nil -> ys
    | Cons head tail ->  Cons head (combine tail ys)
;

instance Monoid LinkedList 'T =
  let zero = Nil
;


Examples of code:


# refinement types
type IntChico = Int ${ i -> i <= 5 }

let a: IntChico = 3 # OK

#does not type check
#let b: IntChico = 20

#can also use the new type constructor
let b = IntChico 5

fn chico a = IntChico a




# brings map to the current scope
# allowing us to avoid writing Functor.map
# Since Monoid is a semigroup, no need to import it, too
use Functor._
    Monoid._

let xs = [ 1 2 3 ]

fn double x = x * 2

# [ 2 4 6 ]
let doubled = map double xs

# curryfication!
# doubler: LinkedList 'T -> LinkedList 'T
let doubler = map double

# [ 4 8 12 ]
let twice = doubler doubled

# [ 2 3 4 ]
let incremented = map (x -> x + 1) xs

# [ 1 2 3 2 3 4 ]
let combined = combine xs incremented

# sequence syntax
# sequence literals  are desugared to Arrays (contigous memory, fixed size)
# but if a LinkedList is infered it is def

#empty array literal
# type
let x0 = []

# this desugars to `let ns = Cons 1 (Cons 2 (Cons 3 Nil))`
let ns: List Int = [ 1 2 3 ]


# x : Seq String
let x = ["f" "e" "d" "e"]

# also x : Seq String
# the ??? thing lets compilation continue without a body if types check. the type of ??? is Bottom (the bottom type)
let x : [] String = ???

# the cons ([::]) pattern match, takes the first element of the list and the tail.
fn matchList l =
  l match
    | []            -> "empty"
    | [a]           -> a
    | [a b]         -> a + b
    | [ a :: tail ] -> a



# Maybe could be a type def
# `type Maybe 'T = 'T | ()`
# but enums are more flexible
# with an enum when you say One x, inference is precise.
# you know it is a Maybe 'T for whatever 'T.
# with a union type it will be frequently infered as
# either unit or the concrete type
# see usage below

enum Maybe 'T =
  | One: 'T
  | None

# empty :: Maybe 'T -> Boolean
fn empty match
    | None -> true
    | _  -> false

let maybeString = One "fede"

# empty :: Maybe 'T -> Boolean
fn nonEmpty maybe =
  ! empty maybe


type Species =
    Cat
  | Doc
  | Bird
  | Fish
  | Reptile

# record type
type Pet =
{
  name:     String
  species:  Species
}

# record type
type Person =
{
  name: String
  pet:  Maybe Pet
}

# hasPet :: 'T : { pet: Maybe Pet } -> Boolean
fn hasPet p =
  nonEmpty p.pet

# nameOf :: 'T : { name: String } -> String
fn nameOf (p): String =
  p.name

let zur     = Pet     "Zur"     Species.Cat
let fede    = Person  "Fede"    (Maybe.One zur)
let victor  = Person  "Victor"  Maybe.None

let pv = hasPet victor # false
let pf = hasPet fede   # true

# does not compile
# let pz = hasPet zur






BEGIN_GRAMMAR

grammar MinnieML;

// Parser Rules ----------------------------------------------------------------------

// Script Rules ----------------------------------------------------------------------

//
// `Script` represents a scripting session's syntax.
//  Not used by normal compiler, scripts are a bit more lenient.
// Syntactically you can write an expression that does not bind it's result, a statement.
// The effects system is far more lenient, too.
//
script: (open)* (use)* ( stat | member )* EOF;

// A statement ignores results if any and evaluates effects immediately
// Scripts dont enforce effectful segregation
stat: exp;

// ----------------------------------------------------------------------
// Full language rules follow
// ----------------------------------------------------------------------

// Modules --------------------------------------------------------------

modVisibility: pub | protd | lexical;

// Public modules are accessible from everywhere
// Default for top level modules unless specified otherwise
pub: Pub;

// Protected modules are only accesible from siblings and parent
// default if not specified otherwise
protd: Protd;

// Lexically visible modules are accesible by children of the declaring module.
lexical: Lexical;

module:
  (doc)? (modVisibility)? (Module moduleId Def)? (open)* (moduleExports)? (member)+ (EOF);

nestedModule:
  (doc)? (modVisibility)? Module moduleId Def (moduleExports)? (member)+ End;

exportSelection:
  (id | tpId | moduleId | selection);

exportReSpec:
  (idMWT | tpId | moduleId);

exportedMember:
  (doc)? ( exportReSpec '=' )? (exportSelection);

moduleExports:
  (doc)? Exports Def ( exportedMember )+ End;

member: ( decl | comm |  use  );

open: Open moduleId (openUses)? ;
openUses: (use)+ End;

use: Use (selection) (selection)*;


decl:
  letBnd        |
  fn            |
  fnM           |
  op            |
  nestedModule  |
  enumDef       |
  tpDef         |
  protocol      |
  instance      ;

// ----------------------------------------------------------------------
// Expressions
//
// Application, Operators, precedence, associativity, type construction, etc,
// are all recognized post parsing
//

group: Lpar ( exp )+ Rpar;

exp:
  flatExp                       #flatExpL       |
  fnMatchLit                    #fnMatchLitL    |
//  left = Lpar exp Rpar          #gr
  left = exp Match matchBody    #matchExpL      ;

flatExp:
    (
      group     |
      fnLit     |
      lit       |
      id        |
      tpCons    |
      tpId      |
      opId      |
      moduleId  |
      tuple     |
      selection |
      cond      |
      dtCons    |
      tpCons    |
      hole
    )+
;

selection: ( id | moduleId )  (Dot (id | moduleId) )* (Dot '_')? ;

hole: Hole;

//
// Protocols ----------------------------------------------------
//

protocol: Protocol (canon)? tpId typeArgs ( Implies tpSpec (',' tpSpec)* )? Def (protocolMember)+ End;
protocolMember:  (id | binOpId | prefixOpId | postfixOpId) (TpArgId)* TpAsc ( tpSpec );

// When an instance is defined as canonical,
// it's the only instance possible within the module
// it is defined on and it's children.
canon: Canon;

instance: (canon)? Instance tpId tpSpec Def (instanceMember)+ End;
instanceMember:  ( letBnd | fn | fnM | op | nestedModule | enumDef | tpDef )+;
//
// Pattern matching ----------------------------------------------------
//

matchBody: matchCase ( matchCase )*;
matchCase: '|' matchBnd? patt ( If exp )? TArrow fnExp ;
matchBnd: (id '@');


patt: lit           |
      idOrMeh       |
      tpSpec        |
      tupleDecon    |
      nominalDecon  |
      tpDecon       |
      structDecon   |
      seqDeconT     |
      seqDeconLit   ;

// ----------------------------------------------------------------------
// Function and/or binding modifiers

rec:  Rec;
lazy: Lazy;
cnst: Const;

// ----------------------------------------------------------------------
// Bindings

bnd:  idMWT         Def exp  |
      tupleDecon    Def exp  |
      nominalDecon  Def exp  |
      structDecon   Def exp  ;

letBnd: (doc)? Let (lazy|cnst)? (rec)? (doc)? bnd (',' (doc)? bnd)*  ;

// ----------------------------------------------------------------------
// Functions

fnLet:  (doc)? Let bnd (',' bnd)* In fnExp (Where fnLetWhereFn (',' fnLetWhereFn)*  )? ;
fnLetWhereFn: (rec)? id fnSig Def fnExp;

fnExp: exp | fnLet;

fnSig: (typeArgs)? formalArgs (returnTp)?;

formalArgs: idMWT* | '(' idMWT* ')';

returnTp: TpAsc tpSpec;

fn:    (doc)? Fn (rec)? id fnSig Def fnExp ;
fnM:   (doc)? Fn (rec)? id ( (typeArgs)? | Lpar (typeArgs)? Rpar )  (returnTp)? Match matchBody ;

fnLit:      fnSig TArrow fnExp;
fnMatchLit: Meh Match matchBody;

// Operators ----------------------------------------------------------------------

op: binOp | prefixOp | postfixOp;

binOpId: opId (opPrecedence)?;
prefixOpId: opId Dot (opPrecedence)?;
postfixOpId: Dot opId (opPrecedence)?;

binOp:       (doc)? Op binOpId      (typeArgs)? idMWT idMWT (returnTp)? Def fnExp;
prefixOp:    (doc)? Op prefixOpId   (typeArgs)? idMWT (returnTp)?   Def fnExp;
postfixOp:   (doc)? Op postfixOpId  (typeArgs)? idMWT (returnTp)?   Def fnExp;

opPrecedence:  LitPrec;

// Conditional expression ----------------------------------------------------------------------

cond: If cndThenExp (Else If cndThenExp)? cndElse;

cndThenExp: exp Then fnExp;
cndElse: Else fnExp;

// TYPES ---------------------------------------------------------------------------------------

// Type def
tpDef: (doc)? Type tpId (typeArgs)? Def tpSpec (tpRefinement)?  ;

// General type declaration related rules

typeArgs: tpArgId typeArgs | tpArgId;

tpArgId: TpArgId | tpArgId TpAsc tpSpec;

tpRefinement: '$'  LCurly (id TArrow )?exp RCurly;

tpSpec:
    Lpar (tpSpec)+ Rpar                           #groupSpec            |
    left = tpSpec ( tpSpec )+                     #tpAppSpec            |
    tpId                                          #nameSpec             |
    tpArgId                                       #argSpec              |
    left = tpSpec ( '&' tpSpec )+                 #intersectSpec        | // Intersection types
    left = tpSpec ( '|' tpSpec )+                 #unionSpec            | // Union types
    left = tpSpec (TArrow left = tpSpec)+         #fnSpec               |
    LCurly dtField (dtField)* RCurly              #structSpec           |
    tpSpec ( ',' tpSpec )+                        #tupleSpec            |
    tpRefinement                                  #refinementSpec       |
    unit                                          #tpUnit               |
    litEmptySeq                                   #tpSeq                ;


unit: LitUnit;

expSeq: (exp)+;
tpCons: tpId expSeq | tpId | tpSpec;
tpDecon: tpId (idOrMeh)+;

// -----------------------------------------------------------------------------
// Product types ---------------------------------------------------------------
// -----------------------------------------------------------------------------

// Data types ----------------------------------------------------------------------

dtField: (doc)? idWT;

dtNamedAssign: Id Def exp;

dtCons: tpId ( dtNamedAssign | exp )+;

nominalDecon: tpId LCurly (idMWT)+ RCurly;

structDecon: LCurly idMWT RCurly;

// Tuples ----------------------------------------------------------------------

tuple: Lpar exp (',' exp)+  Rpar;

tupleDecon: Lpar idOrMeh ',' idOrMeh ( ',' idOrMeh )*  Rpar;

// -----------------------------------------------------------------------------
// Sum types -------------------------------------------------------------------
// -----------------------------------------------------------------------------


// Variants (discriminated unions)  -------------------------------------------------------------------
// enum  -------------------------------------------------------------------

enumDef: (doc)? Enum tpId (typeArgs)? Def enumMbr ( enumMbr )+ ;

enumMbr:  (doc)?  '|'  tpId ( TpAsc tpSpec)?;



//
// Literals ----------------------------------------------------------------------
//

lit: litStr | litInt | litLong | litFloat | litDouble | litUnit | litBoolean |  litEmptySeq | litSeq ;

litStr: LitStr;
litInt:  LitInt;
litLong: LitLong;

litFloat:  LitFloat;
litDouble: LitDouble;

litBoolean: (litTrue | litFalse);
litTrue: LitTrue;
litFalse: LitFalse;

litUnit: LitUnit;

litSeq: LBrac (exp)* RBrac;
litEmptySeq: LBrac RBrac;
seqDeconLit: LBrac (id)* RBrac;
seqDeconT: LBrac (id '::' id) RBrac;

// Comments  ----------------------------------------------------------------------

doc: Doc;

comm: (hComm | mlComm) ;

hComm: HComm;

mlComm: MLComm;

// Ids ----------------------------------------------------------------------

id:       Id;
idWT:     id TpAsc tpSpec;
idMWT:    id (TpAsc tpSpec)?;
idOrMeh:  Meh | idMWT;
moduleId: FirstUpId;
tpId:     FirstUpId;
opId:     SymId | Id;

// Lexer Rules ----------------------------------------------------------------------

// Literals
LitStr:   '"' .*? '"';
LitInt:   [0-9]+;
LitFloat: [0-9]*'.'[0-9]+;
LitLong:  [0-9]+'L';
LitDouble: [0-9]*'.'[0-9]+'D';
LitTrue:  'true';
LitFalse: 'false';
LitUnit : '()';
LitPrec: '[' [1-10] ']';

// Keywords
Type :      'type';
TpAsc:      ':';
Let :       'let';
Where:      'where';
Rec:        'rec';
Const:      'const';
Fn :        'fn';
In:         'in';
If:         'if';
Then:       'then';
Else:       'else';
Module:     'module';
Pub:        'pub';
Protd:      'protected';
Lexical:    'lexical';
Exports:    'exports';
Open:       'open';
Use:        'use';
Enum:       'enum';
Data:       'data';
Match:      'match';
Lazy:       'lazy';
Or:         'or';
And:        'and';
TArrow:     '->';
Op:         'op';
End :       ';';
Def :       '=';
Dot:        '.';
Lpar :      '(';
Rpar :      ')';
LCurly:     '{';
RCurly:     '}';
LBrac:      '[';
RBrac:      ']';
Implies:    '<:';
Hole:       '???';
Meh:        '_';
Compose:    '<|';
AndThen:    '|>';
Protocol:   'protocol';
Instance:   'instance';
Canon:      'canon';
//SeqCons:    '::';


// Identifiers

// a value binding id starts with a lowercase letter
Id : FirstLowId;

// A type parameter starts with a ' and an upper case letter
TpArgId : [']FirstUpId;

FirstLowId: [a-z][A-Za-z0-9_]*;
FirstUpId : [A-Z][A-Za-z0-9]* ;

SymId : ( '/' | '*' | '+' | '-' | '>' | '<' | '=' | ':' | '|' | '%' | '\\' | '^' | '!' | '~' | '?'  )+;

// Whitespace
Newline : ('\r\n' | '\n')   -> channel(1);
WS      : [\t ]+            -> channel(1);

// Comments
// Doc comment
Doc     : '(**' (Doc|MLComm|.)*? '*)';
// Multiline comment
MLComm  : '(*' (MLComm|Doc|.)*? '*)'        -> channel(2);
// Line comment
HComm   : '#' .*? ('\r\n' | '\n' | EOF)     -> channel(2);




END_GRAMMAR

Wait for questions,
and when you provide code snippets all should be using MinnieML (mml for short) code unless otherwise directed,
use the same indentation style as the examples provided,
and  strictly follow the provided grammar, not doing so induces great stress on me
